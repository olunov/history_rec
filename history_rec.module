<?php


/**
 * @see http://drupal.org/project/history_rec
 */

/**
 * Implements hook_help().
 */
function history_rec_help($path, $args) {
  $output = '';
  switch ($path) {
    case "admin/help#history_rec":
      $output = '<p>'.  t("This module generates node recommendations based on user browsing history") .'</p>';
      break;
  }
  return $output;
}

/**
 * Implements hook_menu().
 */ 
function history_rec_menu() {
  $items = array();
  $items['admin/config/recommender/history_rec'] = array(
    'title' => 'Browsing History Recommender',
    'description' => 'Configure the Browsing History Recommender',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('history_rec_settings_form'),
    'access arguments' => array('administer recommender'),
    'file' => 'history_rec.admin.inc'
  );
  return $items;
}


/**
 * Implements hook_views_api().
 */
function history_rec_views_api() {
  return array(
    'api' => 3,
  );
}

/**
 * Implements hook_cron().
 */
function history_rec_cron() {
  if (variable_get('history_rec_source' == 'accesslog')) {
    _history_rec_update_accesslog();
  }
}

//function _history_rec_update_history() {
//  $last_updated = _history_rec_last_updated();
//  $query = db_select('history')->fields('history', array('uid', 'nid', 'timestamp'))->condition('timestamp', $last_updated, '>');
//  // TODO: this should be db_merge
//  db_insert('history_rec_browsing')->from($query)->execute();
//}


function _history_rec_update_accesslog() {
  // retrieve hostname to be updated from {history_rec_user_mapping}
  $last_updated = _history_rec_last_updated();
  $sub_query = db_select('history_rec_user_mapping', 'm')->fields('m', array('hostname'))->distinct();
  $query = db_select('accesslog', 'a')->fields('a', array('hostname'))->distinct();
  $query->condition('timestamp', $last_updated, '>');
  $query->condition('uid', 0);
  $query->condition('hostname', $sub_query, 'NOT IN');
  $query->execute();
  
  // update {history_rec_user_mapping}
  $euid = db_query('SELECT MIN(euid) FROM {history_rec_user_mapping}');
  $insert = db_insert('history_rec_user_mapping')->fields(array('euid', 'uid', 'hostname', 'created'));
  foreach ($query->fetchCol() as $hostname) {
    $euid -= 1;
    $insert->values(array($euid, 0, $hostname, time()));
  }
  $insert->execute();
  
  // update records from {accesslog}
  $query = db_query('SELECT path, hostname, uid, timestamp FROM {accesslog} WHERE path LIKE "node/%" AND timestamp > :last_updated', array(':last_updated'=>$last_updated));
  foreach ($query->fetchAllAssoc() as $row) {
    $nid = substr($row['pathph'], 5); // strip "node/"
    if ($row['uid'] > 0) {
      $euid = $row['uid'];
    }
    else {
      $euid = db_query('SELECT euid FROM {history_rec_user_mapping} WHERE hostname=:hostname', array(':hostname' => $row['hostname']))->fetchField();
    }
    db_merge('history_rec_browsing')
      ->key(array('euid', 'nid'))
      ->fields(array(
        'euid' => $row['uid'],
        'nid' => $nid,
        'updated' => $row['timestamp'],
      ))
      -> updateFields(array(
        'updated' => $row['timestamp'],
      ))
      ->execute();
  }
}


function _history_rec_last_updated() {
  // max() is ANSI standard and is acceptable here: http://drupal.org/node/773090
  $last_updated = db_query('SELECT MAX(updated) FROM {history_rec_browsing}')->fetchField();
  if ($last_updated == NULL) {
    $last_updated = 0;
  }
  return $last_updated;
}

