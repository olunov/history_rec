<?php


/**
 * @see http://drupal.org/project/history_rec
 */

/**
 * Implements hook_help().
 */
function history_rec_help($path, $args) {
  $output = '';
  switch ($path) {
    case "admin/help#history_rec":
      $output = '<p>'.  t("This module generates node recommendations based on user browsing history") .'</p>';
      break;
  }
  return $output;
}

/**
 * Implements hook_menu().
 */ 
function history_rec_menu() {
  $items = array();
  $items['admin/settings/recommender/history_rec'] = array(
    'title' => 'Browsing History Recommender',
    'description' => 'Configure the Browsing History Recommender',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('history_rec_settings_form'),
    'access arguments' => array('administer recommender'),
    'file' => 'history_rec.admin.inc'
  );
  return $items;
}


/**
 * Implements hook_views_api().
 */
function history_rec_views_api() {
  return array(
    'api' => 2,
  );
}

/**
 * Implements hook_cron().
 */
function history_rec_cron() {
  if (variable_get('history_rec_source') == 'accesslog') {
    _history_rec_update_accesslog();
  }
}

//function _history_rec_update_history() {
//  $last_updated = _history_rec_last_updated();
//  $query = db_select('history')->fields('history', array('uid', 'nid', 'timestamp'))->condition('timestamp', $last_updated, '>');
//  // TODO: this should be db_merge
//  db_insert('history_rec_browsing')->from($query)->execute();
//}


/**
 * take data from accesslog and make them usable as user-item preference.
 */
function _history_rec_update_accesslog() {
  // retrieve hostname to be updated from {history_rec_user_mapping}
  $last_updated = _history_rec_last_updated();
  $result = db_query('SELECT DISTINCT a.hostname FROM {accesslog} a WHERE timestamp > %d AND uid = 0
      AND hostname <> ANY (SELECT DISTINCT m.hostname FROM {history_rec_user_mapping} m)', $last_updated);
  
  // update {history_rec_user_mapping}
  $euid = db_result(db_query('SELECT MIN(euid) FROM {history_rec_user_mapping}'));
  while ($row = db_fetch_array($result)) {
    $euid -= 1;
    db_query('INSERT INTO {history_rec_user_mapping}(euid, uid, hostname, created) VALUE(%d, %d, %s, %d)', $euid, 0, $row['hostname'], time());
  }
  
  // update records from {accesslog}
  $result = db_query("SELECT path, hostname, uid, timestamp FROM {accesslog} WHERE path LIKE 'node%' AND timestamp > %d", $last_updated);
  while ($row = db_fetch_array($result)) {
    $nid = substr($row['path'], 5); // strip "node/"   
    if (!is_numeric($nid)) continue;  // skip the ones like node/21/edit
    $updated = $row['timestamp'];
    
    if ($row['uid'] > 0) {
      $euid = $row['uid'];
    }
    else {
      $euid = db_result(db_query('SELECT euid FROM {history_rec_user_mapping} WHERE hostname=%s', $row['hostname']));
    }
    
    // to prevent duplicate results, remove old data first.
    db_query('DELETE FROM {history_rec_browsing} WHERE euid=%d AND nid=%d', $euid, $nid);
    db_query('INSERT INTO {history_rec_browsing}(euid, nid, updated) VALUE(%d, %d, %d)', $euid, $nid, $updated);
  }
}


function _history_rec_last_updated() {
  // max() is ANSI standard and is acceptable here: http://drupal.org/node/773090
  $last_updated = db_result(db_query('SELECT MAX(updated) FROM {history_rec_browsing}'));
  if (!($last_updated > 0)) {
    $last_updated = 0;
  }
  return $last_updated;
}

